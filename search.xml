<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ARM指令和指令系统]]></title>
      <url>http://ideask.cf/2017/02/01/arm-asm/</url>
      <content type="html"><![CDATA[<pre><code>指令是指示计算机某种操作的命令，指令的集合称为指令系统。指令系统的功能强弱很大程度上决定了这类计算机智能的高低，它集中地反应了微处理器的硬件功能和属性。
ARM指令在机器中的表示格式是用32位的二进制数表示。如ARM中有一条指令为
    ADDEQS  R0，R1，#8；
其二进制代码形式为：
31~28    |    27~25    |    24~21    |    20    |    19~16    |     15~12    |    11~0
0000    |    001        |    0100    |    1    |    0001    |    0000    |    0000 0000 1000
cond    |        opcode                    |    Rn        |    Rd        |    Op2

ARM指令格式一般如下：
&lt;opcode&gt;    {&lt;cond&gt;}{s}&lt;Rd&gt;，&lt;Rn&gt;{，&lt;OP2&gt;}
格式中&lt; &gt;的内容是必不可少的，{ }中的内容可忽略

&lt;opcode&gt;    表示操作码。如ADD表示算术加法
{&lt;cond&gt;}        表示指令执行的条件域。如EQ、NE等，缺省为AL。
{S}    决定指令的执行结果是否影响CPSR的值，使用该后缀则指令执行结果影响CPSR的值，否则不影响
&lt;Rd&gt;    表示目的寄存器
&lt;Rn&gt;    表示第一个操作数，为寄存器
&lt;op2&gt;    表示第二个操作数，可以是立即数。寄存器和寄存器移位操作数
</code></pre><h2 id="ARM指令后缀：S、！"><a href="#ARM指令后缀：S、！" class="headerlink" title="ARM指令后缀：S、！"></a>ARM指令后缀：S、！</h2><pre><code>S后缀：指令中使用S后缀时，指令执行后程序状态寄存器的条件标志位将被刷新，不使用S后缀时，指令执行后程序状态寄存器的条件标志将不会发生变化。S后缀常用于对条件进行测试，如是否有溢出，是否进位等，根据这些变化，就可以进行一些判断，如是否大于，相等，从而影响指令执行的顺序。
！后缀：如果指令地址表达式中不含！后缀，则基址寄存器中的地址值不会发生变化。加上此后缀后，基址寄存器中的值（指令执行后） =  指令执行前的值 + 地址偏移量
    （1）！后缀必须紧跟在地址表达式后面，而地址表达式要有明确的地址偏移量
    （2）！后缀不能用于R15（PC）的后面
    （3）当用在单个地址寄存器后面时，必须确信这个寄存器有隐性的偏移量，例如“STMDB  R1！，{R3，R5，R7}”。此时地址基址寄存器R1的隐性偏移量为4（一条指令占32位，即4个字节）
</code></pre><h2 id="指令的条件码：31-28位4个字节存储，共16个条件码"><a href="#指令的条件码：31-28位4个字节存储，共16个条件码" class="headerlink" title="指令的条件码：31-28位4个字节存储，共16个条件码"></a>指令的条件码：31-28位4个字节存储，共16个条件码</h2><pre><code>条件码            助记符后缀            标志                含义
0000            EQ                    Z置位                相等
0001            NE                    Z清零                不相等
0010            CS                    C置位                无符号数大于或等于
0011            CC                    C清零                无符号数小于
0100            MI                    N置位                负数
0101            PL                    N清零                正数或零
0110            VS                    V置位                溢出
0111            VC                    V清零                未溢出
1000            HI                    C置位 Z清零            无符号数大于
1001            LS                    C清零 Z置位            无符号数小于或等于
1010            GE                    N等于V                带符号数大于或等于
1011            LT                    N不等于V            带符号数小于
1100            GT                    Z清零且（N等于V）    带符号数大于
1101            LE                    Z置位或（N不等于V）    带符号数小于或等于
1110            AL                    忽略                无条件执行
</code></pre><h2 id="ARM指令分类：六大类"><a href="#ARM指令分类：六大类" class="headerlink" title="ARM指令分类：六大类"></a>ARM指令分类：六大类</h2><pre><code>ARM指令集可以分为数据处理指令，数据加载指令和存储指令，分支指令，程序状态寄存器（PSR）处理指令，协处理器指令和异常产生指令六大类。
</code></pre><h2 id="ARM指令的寻址方式：8类"><a href="#ARM指令的寻址方式：8类" class="headerlink" title="ARM指令的寻址方式：8类"></a>ARM指令的寻址方式：8类</h2><pre><code>ARM指令的寻址方式一般可以分为8类：立即数寻址，寄存器寻址，寄存器间接寻址，寄存器移位寻址，基址变址寻址，多寄存器寻址，相对寻址，堆栈寻址等
举例：
MOV    R0，#15            ；立即数15放入寄存器R0中
ADD    R0，R1，R2        ；R0 &lt;= R1+R2
LDR    R0，[R4]        ；R0 &lt;= [R4]（R4中存放的是一个指针变量，[ ]表示取改地址值指向的内容）
ADD    R0，R1，R2，LSL #1        ；R0 &lt;= R1+R2（R2左移一位后的值）
MOV    R0，R1，LSL R3    ；R0 &lt;= R1（R1左移R3位后）
LDR    R0，[R1，#4]    ；R0 &lt;= [R1+4]
LDR    R0，[R1，#4]!    ；R0 &lt;= [R1+4]，R1 &lt;= R1+4。同时更新基址
LDR    R0，[R1]，#4    ；R0 &lt;= [R1]，R1 &lt;= R1+4
LDR    R0，[R1，R2]    ；R0 &lt;= [R1+R2]
LDMIA    R0!，{R1 - R4}    ；R1 &lt;= [R0]、R1 &lt;= [R0+4]、R1 &lt;= [R0+8]、R1 &lt;= [R0+12]
BL        proc                ；跳转到子程序proc处执行，执行完毕后返回（L标记，带返回的跳转）。
STMFD    R13!，{R0 - R4}    ；R0-R4压栈，FD为满栈递减，地址从高到低，R13为SP堆栈指针
LDMFD    R13!，{R0 - R4}    ；R0-R4出栈，FD为满栈递减
</code></pre><h2 id="ARM寄存器数据处理指令："><a href="#ARM寄存器数据处理指令：" class="headerlink" title="ARM寄存器数据处理指令："></a>ARM寄存器数据处理指令：</h2><h3 id="1、数据处理指令机器编码格式："><a href="#1、数据处理指令机器编码格式：" class="headerlink" title="1、数据处理指令机器编码格式："></a>1、数据处理指令机器编码格式：</h3><pre><code>31~28    |    27~26    25    |    24~21    |    20    |    19~16    |     15~12    |    11~0
cond    |       00        I    |    opcode    |    S    |    Rn        |    Rd        |    Op2

    cond：指令执行的条件码
    I：用于区别第二操作数是立即数（I=1）还是寄存器移位（I=0）
    opcode：数据处理指令操作码
    S：用于设置条件码，S=0时，条件码不改变，S=1时，条件码根据具体指令的结果修改
    Rn：第一操作数寄存器
    Rd：目标寄存器
    Op2：第二操作数，该数可以是立即数或寄存器移位数
</code></pre><h3 id="2、数据传送指令：MOV-MVN"><a href="#2、数据传送指令：MOV-MVN" class="headerlink" title="2、数据传送指令：MOV  MVN"></a>2、数据传送指令：MOV  MVN</h3><pre><code>MOV    R1，R0        ；将寄存器R0的值传送到寄存器R1
MOV    PC，R14    ；将寄存器R14的值传送到PC，常用于子程序返回
MOV    R1，R0，LSL #3        ；将寄存器R0的值左移3位后传送到R1
MOV    R0，#5        ；将立即数5传送到寄存器R0
MVN    R0，#0        ；将立即数0按位取反后传送到寄存器R0中，完成后R0 = -1
MVN    R1，R2        ；将R2按位取反后，结果存到R1
</code></pre><h3 id="3、移位指令：LSL、LSR、ASR、ROR、RRX"><a href="#3、移位指令：LSL、LSR、ASR、ROR、RRX" class="headerlink" title="3、移位指令：LSL、LSR、ASR、ROR、RRX"></a>3、移位指令：LSL、LSR、ASR、ROR、RRX</h3><pre><code>MOV    R0，R1，LSL #1        ；寄存器R1左移一位后传送到R0
MOVS    R0，R1，LSL #1        ；寄存器R1左移一位后传送到R0，并更新状态标志位
MOVS    R0，R1，LSR #1        ；寄存器R1右移一位后传送到R0，并更新状态标志位
MOVS    R0，R1，ASR #1        ；寄存器R1算术右移一位后传送到R0，并更新状态标志位
                            ；算术右移，第一位符号位不变
MOV    R0，R1，ROR #1    ；寄存器R1循环右移一位后传送到R0
MOVS    R0，R1，RRX        ；寄存器R1循环右移一位后传送到R0，用C标志位作为最高位扩展
</code></pre><h3 id="4、算术指令：ADD、ADC、SUB、SBC、RSB、RSC"><a href="#4、算术指令：ADD、ADC、SUB、SBC、RSB、RSC" class="headerlink" title="4、算术指令：ADD、ADC、SUB、SBC、RSB、RSC"></a>4、算术指令：ADD、ADC、SUB、SBC、RSB、RSC</h3><pre><code>ADD    R0，R1，R2            ；寄存器R1和R2的值相加后传送到R0
ADD    R0，R1，#5            ；寄存器R1的值加上5后传送到R0
ADD    R0，R1，R2，LSL #2        ；寄存器R2左移两位后与R1相加，得到的结果传送到R0
ADD    R0，R1，R2，LSL R3    ；寄存器R2左移R3后与R1相加，得到的结果传送到R0
ADDS    R0，R2，R4            ；64位加，低位放在R0
ADC    R1，R3，R5            ；64位加，高位放在R1，注意要加上低位的进位
SUB    R0，R1，R2            ；寄存器R1和R2的值相减后传送到R0
SUB    R0，R1，#6            ；寄存器R1的值减6后传送到R0
SUB    R0，R1，R2，LSL #1        ；R1与寄存器R2左移一位后的值相减，得到的结果传送到R0
SUBS    R0，R2，R4            ；64位减，低位放在R0
SBC    R1，R3，R5            ；64位减，高位放在R1，注意要减去低位的借位    
RSB    R0，R1，R2            ；寄存器R2和R1的值相减后传送到R0，注意是R2-R1，方向相反
RSB    R0，R1，#6            ；6与寄存器R1的值相减后传送到R0
RSB    R0，R1，R2，LSL #1        ；寄存器R2左移一位后与R1相减，得到的结果传送到R0
RSC    R0，R1，R2            ；寄存器R2和R1的值相减，再减去借位后传送到R0
</code></pre><h3 id="5、逻辑运算指令：AND、ORR、EOR、BIC"><a href="#5、逻辑运算指令：AND、ORR、EOR、BIC" class="headerlink" title="5、逻辑运算指令：AND、ORR、EOR、BIC"></a>5、逻辑运算指令：AND、ORR、EOR、BIC</h3><pre><code>AND    R0，R0，#0xF        ；R0的值与0xF相位与后的值传送到R0
ORR    R0，R0，#9            ；R0的值与9相位与后的值传送到R0
EOR    R0，R0，#0xF        ；R0的值与0xF相异或后的值传送到R0
BIC        R0，R0，#9            ；位清除指令R0的第0位和第3位清零
</code></pre><h3 id="6、比较指令：CMP、CMN、TST、TEQ"><a href="#6、比较指令：CMP、CMN、TST、TEQ" class="headerlink" title="6、比较指令：CMP、CMN、TST、TEQ"></a>6、比较指令：CMP、CMN、TST、TEQ</h3><pre><code>CMP    R1，#10                ；将寄存器R1的值与10相减，并设置CPSR标志位
ADDGT    R0，R0，#5            ；如果R1&gt;10，则执行ADDGT指令，将R0加5
CMN    R0，R1                ；R0 - (-R1)，反值比较，影响CPSR标志位
CMN    R0，#10                ；R0 - (-10)，反值比较，影响CPSR标志位
TST        R1，#3                ；检查R1中第0位和第1位是否为1，根据结果更新条件标志位
TEQ    R1，R2                ；将寄存器R1的值与寄存器R2的值进行按位异或，
                            ；并根据结果设置CPSR的标志位
</code></pre><h3 id="7、乘法指令：MUL、MLA、SMULL、SMLAL、UMULL、UMLAL"><a href="#7、乘法指令：MUL、MLA、SMULL、SMLAL、UMULL、UMLAL" class="headerlink" title="7、乘法指令：MUL、MLA、SMULL、SMLAL、UMULL、UMLAL"></a>7、乘法指令：MUL、MLA、SMULL、SMLAL、UMULL、UMLAL</h3><pre><code>MUL    R0，R1，R2            ；R1和R2相乘的结果发送到R0
MULS    R0，R1，R2            ；R1和R2相乘的结果发送到R0，同时设置CPSR的相关条件标志位
MLA    R0，R1，R2，R3    ；R1和R2相乘的结果再加上R3后发送到R0
MLAS    R0，R1，R2，R3    ；R1和R2相乘的结果再加上R3后发送到R0，更新CPSR标志位
SMULL    R0，R1，R2，R3    ；R2和R3相乘的结果的低32位放在R0，高32位放在R1
SMLAL    R0，R1，R2，R3    ；R2和R3相乘的结果的低32位加上R0后放在R0，
                            ；高32位加上R1后放在R1
UMULL    R0，R1，R2，R3    ；无符号数相乘，结果与SMULL类似
UMLAL    R0，R1，R2，R3    ；无符号数乘加，结果与SMLAL类似
</code></pre><h2 id="ARM数据加载和存储指令："><a href="#ARM数据加载和存储指令：" class="headerlink" title="ARM数据加载和存储指令："></a>ARM数据加载和存储指令：</h2><h3 id="1、数据加载和存储的方向。寄存器到存储器方向：Store；从存储器到寄存器方向：Load"><a href="#1、数据加载和存储的方向。寄存器到存储器方向：Store；从存储器到寄存器方向：Load" class="headerlink" title="1、数据加载和存储的方向。寄存器到存储器方向：Store；从存储器到寄存器方向：Load"></a>1、数据加载和存储的方向。寄存器到存储器方向：Store；从存储器到寄存器方向：Load</h3><pre><code>数据加载和存储指令共有三种类型：单寄存器加载和存储指令，多寄存器加载和存储指令 和 交换指令
</code></pre><h3 id="2、数据加载与存储器指令寻址"><a href="#2、数据加载与存储器指令寻址" class="headerlink" title="2、数据加载与存储器指令寻址"></a>2、数据加载与存储器指令寻址</h3><pre><code>LDR    R5，[R6，#0x08]        ；R6寄存器加0x08的和的地址值内的数据传送到R5
STR        R6，[R7]，#-0x08    ；R6寄存器的数据传送到R7存储的地址值指向的存储空间，
                            ；同时更新R7寄存器的内容为R7-0x08
LDR    R5，[R6，R3]        ；R6寄存器加R3的和的地址值内的数据传送到R5
STR        R6，[R7]，-R8        ；R6寄存器的数据传送到R7存储的地址值指向的存储空间，
                            ；同时更新R7寄存器的内容为R7-R8
LDR    R3，[R2，R4，LSL #2]    ；R3 &lt;== [  R2 + R4(R4左移两位)  ]
LDR    R3，[R2]，-R4，LSR #3    ；R3 &lt;== [ R2 ]，R2 = R2-R4（R4右移三位）
LDR    R4，START            ；将标号START标定的空间的数据加载到R4中
</code></pre><h3 id="3、地址索引：前索引、自动索引、后索引"><a href="#3、地址索引：前索引、自动索引、后索引" class="headerlink" title="3、地址索引：前索引、自动索引、后索引"></a>3、地址索引：前索引、自动索引、后索引</h3><pre><code>1】前索引：前索引也称为前变址，这种索引是在指令执行前把偏移量和基址相加减，得到的值作为变量的地址。如：
LDR    R5，[R6，#0x04]
STR        R0，[R5，-R8]
2】自动索引：自动索引也称为自动变址，有时为了修改基址寄存器的内容，使之指向数据传送地址，可使用这种方法自动修改基址寄存器，如：
LDR    R5，[R6，#0x04]！
3】后索引：后索引也被称为后变址，后索引就是用基址寄存器的地址值寻址，找出操作数进行操作，操作完成后，再把地址偏移量和基址相加/减，结果送到基址寄存器，作为下一次寻址的基址。如：
LDR    R5，[R6]，#0x04
STR        R6，[R7]，#-0x08
</code></pre><h3 id="4、单寄存器加载和存储指令：LDR-STR、LDRB-STRB、LDRH-STRH、LDRSB-LDRSH"><a href="#4、单寄存器加载和存储指令：LDR-STR、LDRB-STRB、LDRH-STRH、LDRSB-LDRSH" class="headerlink" title="4、单寄存器加载和存储指令：LDR/STR、LDRB/STRB、LDRH/STRH、LDRSB/LDRSH"></a>4、单寄存器加载和存储指令：LDR/STR、LDRB/STRB、LDRH/STRH、LDRSB/LDRSH</h3><pre><code>1】字数据加载/存储指令格式：
    31~28    |  27~26    | 25 24 23 22 21 20|    19~16    |     15~12    |    11~0
    cond    |     01    |   I    P  U  B   W  L      |    Rn        |    Rd        |    Op2
    cond：指令执行的条件编码
    I、P、U、W：用于区别不同的地址模式（偏移量）。
        I为0时，偏移量为12位立即数；I为1时，偏移量为移位寄存器移位
        P表示前/后索引
        U表示加/减
        W表示回写
    L：L为1时表示加载，L为0时表示存储
    B：B为1表示字节访问，B为0表示字访问
    Rd：源/目标寄存器
    Rn：基址寄存器
    Op2：表示偏移量是一个12位的无符号二进制数，与Rn一起构成地址addr
2】存储器&lt;==&gt;寄存器  LDR/STR
    LDR指令用于从存储器中间一个32位的字数据加载到目的寄存器Rd中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当做目的地址，从而实现程序流程的跳转。
LDR    R4，START            ；将存储地址为START的字数据读入R4
STR        R5，DATA1            ；将R5存入存储地址为DATA1中
LDR    R0，[R1]            ；将存储器地址为R1的字数据读入寄存器R0
LDR    R0，[R1，R2]        ；将存储器地址为R1+R2的字数据读入寄存器R0
LDR    R0，[R1，#8]        ；将寄存器R1+8的内容读入寄存器R0
LDR    R0，[R1，R2，LSL #2]    ；将R1+R2*4的字数据读入寄存器R0
STR        R0，[R1，R2]!        ；将R0字数据存入存储器地址为R1+R2的存储单元中，
                                并将新地址R1+R2写入R1
STR        R0，[R1，#8]!        ；将R0字数据存入存储器地址为R1+8的存储单元中，
                                并将新地址R1+8写入R1
STR        R0，[R1，R2，LSL #2]!    ；将R0字数据存入地址为R1+R2*4的存储单元中，
                                并将新地址R1+R2*4写入R1
LDR    R0，[R1]，#8        ；将存储器地址为R1的字数据读入寄存器R0，
                                并将新地址R1+8写入R1
LDR    R0，[R1]，R2        ；将存储器地址为R1的字数据读入寄存器R0，
                                并将新地址R1+R2写入R1
LDR    R0，[R1]，R2，LSL #2    ；将存储器地址为R1的字数据读入寄存器R0，
                                并将新地址R1+R2*4写入R1
    【备注】注意事项：
    a、立即数绝对值不大于4095的数值，可使用带符号数，即在-4095 ~ +4095之间。（4096D = 1000H）
    b、语句的标号不能指向程序存储器的程序存储区，而是指向程序存储器的数据存储区或数据存储器的数据存储区。另外指向的区域是可修改的。例如，在用户模式下，有些存储区是不能访问的或是只读的。
    c、字传送时，偏移量必须保证偏移的结果能够使地址对齐。
    d、使用寄存器移位的方法计算偏移量时。移位的位数不能超过规定的数值，而且不能用寄存器表示移位的位数。各类移位指令的移位位数规定如下：
            ASR    #n：算术右移（1≤n≤32）
            LSL        #n：逻辑左移（0≤n≤31）
            LSR        #n：逻辑右移（1≤n≤32）
            ROR    #n：循环右移（1≤n≤31）
    e、R15作为基址寄存器Rn时，不可以使用回写功能，即使用后缀“!”，另外，R15不可作为偏移寄存器使用。
</code></pre><h3 id="5、字节数据加载-存储指令：LDRB-STRB"><a href="#5、字节数据加载-存储指令：LDRB-STRB" class="headerlink" title="5、字节数据加载/存储指令：LDRB/STRB"></a>5、字节数据加载/存储指令：LDRB/STRB</h3><pre><code>LDRB指令用于从存储器中将一个8位字节的数据加载到目的寄存器，同时将寄存器的高24位清零。该指令通常用于从存储器中读取8位的字节数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器读取的数据被当做目的地，从而可以实现程序流程的跳转
STRB指令用于从源寄存器中将一个8位的字节数据存储到存储器中，该字节数据为源寄存器的低8位，STRB指令和LDRB指令的区别在于数据的传送方向。
LDRB    R0，[R1]            ；将存储器地址为R1的字节数据读入寄存器R0，
                                并将R0的高24位清零。
LDRB    R0，[R1，#8]        ；将存储器地址为R1+8的字节数据读入寄存器R0，
                                并将R0的高24位清零。
STRB    R0，[R1]            ；将寄存器R0中的字节数据写入以R1为地址的存储器中。
STRB    R0，[R1，#8]        ；将寄存器R0中的字节数据写入以R1+8为地址的存储器中。
</code></pre><h3 id="6、LDRH-STRH-半字数据加载-存储指令"><a href="#6、LDRH-STRH-半字数据加载-存储指令" class="headerlink" title="6、LDRH/STRH 半字数据加载/存储指令"></a>6、LDRH/STRH 半字数据加载/存储指令</h3><pre><code>    31~28|  27~25| 24 23 22 21 20 |    19~16| 15~12| 11~8      | 7   6   5   4   | 3~0
    cond   |     000  |  P  U    I   W   L  |        Rn   |     Rd    | addr_H  |1    S   H   1    |addr_L
    cond：指令执行的条件编码
    I、P、U、W：用于区别不同的地址模式（偏移量）。I为0时，偏移量为8位立即数，I为1时，偏移量为寄存器移位。P表示前/后变址，U表示加/减，W表示回写。
    L：L为1表示加载，L为0表示存储。
    S：用于区别有符号访问（S为1）和无符号访问（S为0）
    H：用于区别半字访问（H为1）或字节访问（H为0）
    Rd：源/目标寄存器
    Rn：基址寄存器
    addr  H / addr  I：表示偏移量，I为0时，偏移量为8位立即数由addr  H和addr  I组成；
    I为1时，偏移量为寄存器移位addr  H为0，addr  L表示寄存器编号
LDR指令用于从寄存器中间一个16位的半字数据加载到目的寄存器Rd中，同时将寄存器的高16位清零，该指令通常用于从存储器中读取16位的半字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的数据被当做目的地址，从而可以实现程序流程的跳转。
LDRH    R0，[R1]            ；将存储器地址R1的半字数据读入寄存器R0，
                                并将R0的高16位清零
LDRH    R0，[R1，#8]        ；将存储器地址为R1+8的半字数据读入寄存器R0，
                                并将R0的高16位清零
LDRH    R0，[R1，R2]        ；将存储器地址为R1+R2的半字数据读入寄存器R0，
                                并将R0的高16位清零
STRH    R0，[R1]            ；将寄存器R0中的半字数据写入以R1为地址的存储器中
使用半字加载/存储指令需要注意的事项：
（1）必须半字地址对齐。
（2）对于R15的使用需要慎重，R15作为基址寄存器Rn时，不可以使用回写功能，不可使用R15作为目的寄存器。
（3）立即数偏移使用的是8位无符号数。
（4）不能使用寄存器移位寻址
</code></pre><h3 id="7、有符号数字节-半字加载指令：LDRSB-LDRSH"><a href="#7、有符号数字节-半字加载指令：LDRSB-LDRSH" class="headerlink" title="7、有符号数字节/半字加载指令：LDRSB / LDRSH"></a>7、有符号数字节/半字加载指令：LDRSB / LDRSH</h3><pre><code>LDRSB指令用于从存储器中间一个8位的字节数据加载到目的寄存器中，同时将寄存器的高24位设置为该字节数据的符号位的值，即将该8位字节数据进行符号位的扩展，生成32位数据；LDRSH指令用于从存储器中将一个16位的半字数据加载到目的寄存器Rd中，同时将寄存器的高16位设置为该字数据的符号位的值，即将该16位字数据进行符号位的扩展，生成32位数据。
LDRSB    R0，[R1，#4]        ；将存储地址为R1+4的有符号字节数据读入R0，
                                R0中的高24位设置为高字节数据的符号位
LDRSH    R6，[R2]，#2        ；将存储地址为R2+2的有符号半字数据读入R6，
                                R6的高16位设置成该字节数据的符号位，R2=R2+2
</code></pre><h3 id="8、多寄存器加载和存储指令：LDM-STM"><a href="#8、多寄存器加载和存储指令：LDM-STM" class="headerlink" title="8、多寄存器加载和存储指令：LDM / STM"></a>8、多寄存器加载和存储指令：LDM / STM</h3><pre><code>LDM指令用于从基址寄存器所指示的一片连续存储器中读取数据到寄存器列表所指示的多个寄存器中，内存单元的其实地址为基址寄存器Rn的值，各个寄存器有寄存器列表regs表示。该指令一般用于多个寄存器数据的出栈操作；STM指令用于将寄存器列表所指示的多个寄存器的值存入到由基址寄存器所指示的一片连续存储器中，内存单元的其实地址为基址寄存器Rn的值，各个寄存器由寄存器列表regs表示。指令的其它参数的用法和LDM指令是相同的。该指令一般用于多个寄存器数据的进栈操作。
type类型。用于数据的存储和读取有一下几种情况：
        IA        每次传送后地址值加
        IB        每次传送前地址值加
        DA        每次传送后地址值减
        DB        每次传送前地址值减
对于堆栈操作有如下几种情况：
        FD        满递减堆栈
        ED        空递减堆栈
        FA        满递增堆栈
        EA        满递增堆栈

{ ! }为可选后缀，若选用该后缀，则当数据加载与存储完毕后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。基址寄存器不允许为R15，寄存器列表可以为R0~R15的任意组合。
{ ^ }为可选后缀，当治疗为LDM且寄存器列表中包含R15，选用该后缀时表示：除了正常数据加载和存储之外，还将SPSR复制到CPSR。同时，该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器。
LDMIA    R0!，{R6-R8}        ；R6 &lt;- [R0]，R7 &lt;- [R0+4]，R8 &lt;- [R0+8]，R0 &lt;- R0+12
LDMIB    R0!，{R6-R8}        ；R6 &lt;- [R0]，R7 &lt;- [R0+4]，R8 &lt;- [R0+8]，R0 &lt;- R0+8
</code></pre><h3 id="9、堆栈和堆栈操作"><a href="#9、堆栈和堆栈操作" class="headerlink" title="9、堆栈和堆栈操作"></a>9、堆栈和堆栈操作</h3><pre><code>堆栈就是在RAM存储器中开辟（指定）的一个特定的存储区域，在这个区域中，信息的存入（此时称为推入）与取出（此时称为弹出）的原则不再是“随机存取”，而是按照“后进先出”的原则就行存取。
A】建栈：规定堆栈底部在RAM存储器中的位置，如：用户可以通过LDR命令设置SP的值来建立堆栈。
LDR    R13，=0x90010        ；
LDR    SP，=0x90010        ；
这时，SP指向地址0x90010，栈内无数据，堆栈底部与顶部重叠，是一个空栈。
B】进栈：STM指令配合FD（满递减）、ED（空递减）、FA（满递增）、EA（空递增）完成入栈操作。在使用一个堆栈的时候，需要确定堆栈在存储器空间中是向上生长还是向下生长的。向上称为递增，向下称为递减。
STMFD    SP!，{R2-R4}        ；把R4，R3，R2的值依次压栈（标号高的存在高地址）
LDMFD    SP!，{R6-R8}        ；把R2，R3，R4的值，依次退到R6，R7，R8
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ARM获得当前PC需要PC=PC+8？]]></title>
      <url>http://ideask.cf/2017/01/26/Pipeline-architecture/</url>
      <content type="html"><![CDATA[<h1 id="ARM获得当前PC需要PC-PC-8？"><a href="#ARM获得当前PC需要PC-PC-8？" class="headerlink" title="ARM获得当前PC需要PC=PC+8？"></a>ARM获得当前PC需要PC=PC+8？</h1><h2 id="1、抛出问题"><a href="#1、抛出问题" class="headerlink" title="1、抛出问题"></a>1、抛出问题</h2><pre><code>为何ARM9和ARM7一样？一个是五级流水线结构，另外一个是三级流水线结构，怎么也是PC=PC+8？ 
</code></pre><h3 id="ARM9五级流水线-VS-ARM7三级流水线"><a href="#ARM9五级流水线-VS-ARM7三级流水线" class="headerlink" title="ARM9五级流水线 VS ARM7三级流水线"></a>ARM9五级流水线 VS ARM7三级流水线</h3><p><img src="http://my.csdn.net/uploads/201207/08/1341755975_5410.png" alt="这里写图片描述"></p>
<h3 id="对应的映射关系"><a href="#对应的映射关系" class="headerlink" title="对应的映射关系"></a>对应的映射关系</h3><p><img src="http://my.csdn.net/uploads/201207/08/1341755957_7798.png" alt="这里写图片描述"></p>
<h2 id="2、解析问题"><a href="#2、解析问题" class="headerlink" title="2、解析问题"></a>2、解析问题</h2><h3 id="先列出ARM9的五级流水线的示例："><a href="#先列出ARM9的五级流水线的示例：" class="headerlink" title="先列出ARM9的五级流水线的示例："></a>先列出ARM9的五级流水线的示例：</h3><p><img src="http://my.csdn.net/uploads/201207/08/1341755941_1321.jpg" alt="这里写图片描述"><br>以uboot中的start.S的最开始的汇编代码为例来进行解释：<br>由反汇编可得：</p>
<pre><code class="bash">00000000 &lt;_start&gt;:
   0:   ea000014   b   58 &lt;reset&gt;
   4:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 20 &lt;_undefined_instruction&gt;</span>
   8:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 24 &lt;_software_interrupt&gt;</span>
   c:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 28 &lt;_prefetch_abort&gt;</span>
  10:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 2c &lt;_data_abort&gt;</span>
  14:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 30 &lt;_not_used&gt;</span>
  18:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 34 &lt;_irq&gt;</span>
  1c:   e59ff014   ldr pc, [pc, <span class="comment">#20] ; 38 &lt;_fiq&gt;</span>

00000020 &lt;_undefined_instruction&gt;:
  20:   00000120   .word  0x00000120
</code></pre>
<p>下面对每一个指令周期，CPU做了哪些事情，分别详细进行阐述：<br>在看下面具体解释之前，有一句话要牢记，那就是：</p>
<pre><code class="bash">PC不是指向你正在运行的指令，而是
PC始终指向你要取的指令的地址。
</code></pre>
<p>认识清楚了这个前提，后面的举例讲解，就容易懂了。<br>指令周期Cycle1<br>（1）取指：<br>PC总是指向将要读取的指令的地址（即我们常说的，指向下一条指令的地址），而当前PC=4，<br>所以去取物理地址为4对对应的指令“ldr pc, [pc, #20]”，其对应二进制代码为e59ff014。<br>此处取指完之后，自动更新PC的值，即PC=PC+4（单个指令占4字节，所以加4）=4+4=8<br>指令周期Cycle2<br>（1）译指：翻译指令e59ff014；<br>（2）同时再去取指：<br>PC总是指向将要读取的指令的地址（即我们常说的，指向下一条指令的地址），而当前PC=8，<br>所以去物理地址为8所对应的指令“ldr pc, [pc, #20]” 其对应二进制代码为e59ff014。<br>此处取指完之后，自动更新PC的值，即PC=PC+4=8+4=12=0xc<br>指令周期Cycle3<br>（1）执行（指令）：执行“e59ff014”，即“ldr pc,[pc, #20]”所对表达的含义，即<br>PC<br>= PC + 20<br>= 12 + 20<br>= 32<br>= 0x20<br>此处，只是计算出待会要赋值给PC的值是0x20，这个0x20还只是放在执行单元中内部的缓冲中。<br>（2）译指：翻译e59ff014。<br>（3）取指：<br>此步骤由于是和上面（1）中的执行同步做的，所以，未受到影响，继续取指，而取指的那一时刻，PC为上一Cycle<br>更新后的值，即PC=0xc，所以是去取物理地址为0xc所对应的指令” ldr pc, [pc, #20]”，对应二进制为e59ff014。<br>其实，分析到这里，大家就可以看出：<br>在Cycle3的时候，PC的值，刚好已经在Cycle1和Cycle2，分别加了4，所以Cycle3的时候，PC=PC+8，而同样道理<br>，对于任何一条指令的，都是在Cycle3，指令的Execute执行阶段，如果用到PC的值，那么PC那一时刻，就是<br>PC=PC+8。<br>所以，此处虽然是五级流水线，但是却不是PC=PC+16，而是PC=PC+8。<br>进一步地，我们发现，其实PC=PC+N的N，是和指令的执行阶段所处于流水线的深度有关，即此处指令的执行<br>Execute阶段，是五级流水线中的第三个，而这个第三阶段的Execute和指令的第一个阶段的Fetch取指，相差的<br>值是 3 -1 =2，即两个CPU的Cycle，而每个Cycle都会导致PC=+PC+4，所以，指令到了Execute阶段，才会发现<br>，此时PC已经变成PC=PC+8了。<br>回过头来反观ARM7的三级流水线，也是同样的道理，指令的Execute执行阶段，是处于指令的第三个阶段，<br>同理，在指令计算数据的时候，如果用到PC，就会发现此时PC=PC+8。<br>同理，假如ARM9的五级流水线，把指令的Execute执行阶段，设计在了第四个阶段，那么就是<br>PC=PC+（第4阶段-1）*4个字节 = PC= PC+12了。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>ARM7的三级流水线，PC=PC+8，<br>ARM9的五级流水线，也是PC=PC+8，<br>根本的原因是，两者的流水线设计中，指令的Execute执行阶段，都是处于流水线的第三级，<br>所以使得PC=PC+8。<br>类似地，可以推导出：<br>假设，Execute阶段处于流水线中的第E阶段，每条指令是T个字节，那么<br>PC<br>= PC + N<em>T<br>= PC + (E - 1) </em> T<br>此处ARM7和ARM9：<br>Execute阶段都是第3阶段-&gt; E=3<br>每条指令是4个字节-&gt; T=4<br>所以：<br>PC<br>=PC + N<em> T<br>=PC + (3 -1 ) </em> 4<br>= PC + 8</p>
<h2 id="关于直接改变PC的值，会导致流水线清空的解释"><a href="#关于直接改变PC的值，会导致流水线清空的解释" class="headerlink" title="关于直接改变PC的值，会导致流水线清空的解释"></a>关于直接改变PC的值，会导致流水线清空的解释</h2><p>   把PC的值直接赋值为0x20。而PC值更改，直接导致流水线的清空，即导致下一个cycle中的，对应的流水线中的<br>其他几个步骤，包括接下来的同一个Cycle中的取指的工作被取消。在PC跳转到0x20的位置之后，流水线重新计算<br>，重新一步步地按照流水线的逻辑，去一点点执行。当然要保证当前指令的执行完成，即执行之后，<br>还有两个cycle，分别做的Memory和Write，会继续执行完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[嵌入式linux系统开发学习路径]]></title>
      <url>http://ideask.cf/2017/01/23/embedded-system-learning/</url>
      <content type="html"><![CDATA[<h1 id="嵌入式linux系统开发学习路径"><a href="#嵌入式linux系统开发学习路径" class="headerlink" title="嵌入式linux系统开发学习路径"></a>嵌入式linux系统开发学习路径</h1><hr>
<p>　  ## 一：C语言<br>　　嵌入式Linux工程师的学习需要具备一定的C语言基础，C语言是嵌入式领域最重要也是最主要的编程语言，通过大量编程实例重点理解C语言的基础编程以及高级编程知识。包括：基本数据类型、数组、指针、结构体、链表、文件操作、队列、栈等。</p>
<p>　　## 二：Linux基础<br>　　Linux操作系统的概念、安装方法，详细了解Linux下的目录结构、基本命令、编辑器VI ,编译器GCC，调试器GDB和 Make 项目管理工具, Shell Makefile脚本编写等知识，嵌入式开发环境的搭建。</p>
<p>　　## 三：Linux系统编程<br>　　重点学习标准I/O库，Linux多任务编程中的多进程和多线程，以及进程间通信(pipe、FIFO、消息队列、共享内存、signal、信号量等)，同步与互斥对共享资源访问控制等重要知识，主要提升对Linux应用开发的理解和代码调试的能力。</p>
<p>　　## 四：Linux网络编程<br>　　计算机网络在嵌入式Linux系统应用开发过程中使用非常广泛，通过Linux网络发展、TCP/IP协议、socket编程、TCP网络编程、UDP网络编程、Web编程开发等方面入手，全面了解Linux网络应用程序开发。重点学习网络编程相关API，熟练掌握TCP协议服务器的编程方法和并发服务器的实现，了解HTTP协议及其实现方法，熟悉UDP广播、多播的原理及编程方法，掌握混合C/S架构网络通信系统的设计，熟悉HTML,Javascript等Web编程技术及实现方法。</p>
<p>　　## 五：数据结构与算法<br>　　数据结构及算法在嵌入式底层驱动、通信协议、及各种引擎开发中会得到大量应用，对其掌握的好坏直接影响程序的效率、简洁及健壮性。此阶段的学习要重点理解数据结构与算法的基础内容，包括顺序表、链表、队列、栈、树、图、哈希表、各种查找排序算法等应用及其C语言实现过程。</p>
<p>　　## 六：C++ 、QT<br>　　C++是Linux应用开发主要语言之一，本阶段重点掌握面向对象编程的基本思想以及C++的重要内容。图形界面编程是嵌入式开发中非常重要的一个环节。由于QT具有跨平台、面向对象、丰富API、支持2D/3D渲染、支持XML、多国语等强大功能，在嵌入式领域的GUI开发中得到了广范的应用，在本阶段通过基于QT图形库的学习使学员可以熟练编写GUI程序，并移植QT应用程序到Cortex-A8平台。包括IDE使用、QT部件及布局管理器、信息与槽机制的应用、鼠标、键盘及绘图事件处理及文件处理的应用。</p>
<p>　　## 七：Cortex A8 、Linux 平台开发<br>　　通过基于ARM Cortex-A8处理s5pv210了解芯片手册的基本阅读技巧，掌握s5pv210系统资源、时钟控制器、电源管理、异常中断控制器、nand flash控制器等模块，为底层平台搭建做好准备。Linux平台包括内核裁减、内核移植、交叉编译、GNU工具使用、内核调试、Bootloader介绍、制作与原理分析、根文件系统制作以及向内核中添加自己的模块，并在s5pv210实验平台上运行自己制作的Linux系统,集成部署Linux系统整个流程。同时了解Android操作系统开发流程。Android系统是基于Linux平台的开源操作系统，该平台由操作系统、中间件、用户界面和应用软件组成，是首个为移动终端打造的真正开放和完整的移动软件，目前它的应用不再局限于移动终端，还包括数据电视、机顶盒、PDA等消费类电子产品。</p>
<p>　　## 八：驱动开发<br>　　驱动程序设计是嵌入式Linux开发工作中重要的一部分，也是比较困难的一部分。本阶段的学习要熟悉Linux的内核机制、驱动程序与用户级应用程序的接口，掌握系统对设备的并发操作。熟悉所开发硬件的工作原理，具备ARM硬件接口的基础知识，熟悉ARM Cortex-A8处理器s5pv210各资源、掌握Linux设备驱动原理框架，熟悉工程中常见Linux高级字符设备、块设备、网络设备、USB设备等驱动开发，在工作中能独立胜任底层驱动开发。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gdb移植和使用方法]]></title>
      <url>http://ideask.cf/2017/01/23/gdb-transplant/</url>
      <content type="html"><![CDATA[<h1 id="gdb移植和使用方法"><a href="#gdb移植和使用方法" class="headerlink" title="gdb移植和使用方法"></a>gdb移植和使用方法</h1><hr>
<h2 id="1、gdb移植"><a href="#1、gdb移植" class="headerlink" title="1、gdb移植"></a>1、gdb移植</h2><pre><code class="bash"><span class="comment">#./configure --target=arm-linux --host=arm-linux</span>
<span class="comment">#make CC=/usr/local/arm/2.95.3/bin/arm-linux-gcc</span>
</code></pre>
<h2 id="2、gdb使用"><a href="#2、gdb使用" class="headerlink" title="2、gdb使用"></a>2、gdb使用</h2><h3 id="2-1、gdb网络调试"><a href="#2-1、gdb网络调试" class="headerlink" title="2.1、gdb网络调试"></a>2.1、gdb网络调试</h3><p>先nfs挂载先<br>开发板：</p>
<pre><code class="bash">gdbserver [电脑的IP地址：端口号] [待调试的程序]
</code></pre>
<p>电脑：</p>
<pre><code class="bash">gdb
target remote [开发板IP地址：端口号]
</code></pre>
<h3 id="2-2、gdb串口调试"><a href="#2-2、gdb串口调试" class="headerlink" title="2.2、gdb串口调试"></a>2.2、gdb串口调试</h3><p>配置串口调试的设置：<br>在xxx-linux-gdb里敲入入下命令：</p>
<pre><code class="bash"><span class="built_in">set</span> remotedevice /dev/ttyS0（这里设置串口1）
<span class="built_in">set</span> remote baud 9600 （这里设置串口波特率）
<span class="built_in">set</span> debug remote 1(可选)
target remote /dev/ttyS0
</code></pre>
<p>如果你用串口1调试hello的话，你就要现在板子上运行命令：</p>
<pre><code class="bash">gdbserver hello /dev/ttyS0 （详情可以参考gdbserver目录下的readme文件）
</code></pre>
<p>这时gdbserver就在等待gdb的应答信号了。<br>然后在pc机上运行命令：</p>
<pre><code class="bash">xxx-linux-gdb hello
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gcc静态编译和动态编译笔记]]></title>
      <url>http://ideask.cf/2017/01/23/gcc-static-dynamic/</url>
      <content type="html"><![CDATA[<h1 id="gcc静态编译与动态编译"><a href="#gcc静态编译与动态编译" class="headerlink" title="gcc静态编译与动态编译"></a>gcc静态编译与动态编译</h1><h2 id="1、静态库"><a href="#1、静态库" class="headerlink" title="1、静态库"></a>1、静态库</h2><p>gcc -c 编译出目标文件 ，而不是直接gcc  直接gcc系统会直接链接目标文件，但是由于缺少main函数所以不成功<br>ar归档工具生成静态库<br>-c 建立备存文件<br>-r 将文件插入备存文件<br>-v 显示执行过程<br>-s 无论ar命令是否修改了库内容都强制重新生成库符号表<br>ar rcvs [libpow.a静态库文件] [unsgn_pow.o 目标文件]<br>将目标文件集合在一起</p>
<h2 id="2、动态库"><a href="#2、动态库" class="headerlink" title="2、动态库"></a>2、动态库</h2><p>gcc -c -fPIC -Wall unsgn_pow.c<br>gcc -shared -o libpow.so unsgn_pow.o<br>gcc -o pow_test pow_test.c -L . -lpow</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim笔记]]></title>
      <url>http://ideask.cf/2017/01/23/vim-note/</url>
      <content type="html"><![CDATA[<h1 id="VIM工具常用快捷键"><a href="#VIM工具常用快捷键" class="headerlink" title="VIM工具常用快捷键"></a>VIM工具常用快捷键</h1><hr>
<p>G 到文件最底部<br>gg 到文件顶部<br>V  行复制框选<br>v  字符复制框选<br>ctrl+v矩形框选</p>
<p>[数字]G  跳到多少行<br>[数字]Enter  向下跳多少行</p>
<p>/[字符串]  查找文中该字符串<br>N向上查找<br>n向下查找</p>
<p>0 该行的第一个字符<br>$ 该行的最后一个字符</p>
<p>dd 删除该行<br>[数字]dd 删除往下[数字]行</p>
<p>yy 复制该行<br>[数字]yy 复制往下[数字]行</p>
<p>u 撤销<br>p 粘贴</p>
<p>vi -o 文件1 文件2多窗口打开<br>ctrl +w+w 窗口间切换</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LCD12864串口驱动udev]]></title>
      <url>http://ideask.cf/2017/01/22/12864-udev-char-device/</url>
      <content type="html"><![CDATA[<h2 id="1、LCD12864串口驱动程序"><a href="#1、LCD12864串口驱动程序" class="headerlink" title="1、LCD12864串口驱动程序"></a>1、LCD12864串口驱动程序</h2><pre><code class="bash"><span class="comment">#include &lt;linux/module.h&gt;</span>
<span class="comment">#include &lt;linux/kernel.h&gt;</span>
<span class="comment">#include &lt;linux/types.h&gt;</span>
<span class="comment">#include &lt;linux/sched.h&gt;</span>
<span class="comment">#include &lt;linux/init.h&gt;</span>
<span class="comment">#include &lt;linux/fs.h&gt;</span>
<span class="comment">#include &lt;linux/ioctl.h&gt;</span>
<span class="comment">#include &lt;linux/delay.h&gt;</span>
<span class="comment">#include &lt;linux/bcd.h&gt;</span>
<span class="comment">#include &lt;linux/capability.h&gt;</span>
<span class="comment">#include &lt;linux/rtc.h&gt;</span>
<span class="comment">#include &lt;linux/cdev.h&gt;</span>
<span class="comment">#include &lt;linux/device.h&gt;</span>
<span class="comment">#include &lt;linux/gpio.h&gt;</span>
<span class="comment">#include &lt;linux/version.h&gt;</span>

<span class="comment">#include &lt;../arch/arm/mach-mx28/mx28_pins.h&gt;</span>

<span class="comment">#define DEVICE_NAME "LCD12864"</span>

<span class="comment">#define LCD_SID 57</span>
<span class="comment">#define LCD_CS 39</span>
<span class="comment">#define LCD_CLK 56</span>

<span class="comment">#define LCD_IOC_MAGIC 'L'</span>
<span class="comment">#define LCD_CMD _IO(LCD_IOC_MAGIC,0)</span>
<span class="comment">#define LCD_LINE _IO(LCD_IOC_MAGIC,1)</span>
<span class="comment">#define LCD_ROW _IO(LCD_IOC_MAGIC,2)</span>
<span class="comment">#define LCD_DATA _IO(LCD_IOC_MAGIC,3)</span>

<span class="comment">#define LCD_IOCTL_MAXNR 4</span>


<span class="comment">#define LCD_SID_H gpio_direction_output(LCD_SID,1);</span>
<span class="comment">#define LCD_SID_L gpio_direction_output(LCD_SID,0);</span>
<span class="comment">#define LCD_CS_H gpio_direction_output(LCD_CS,1);</span>
<span class="comment">#define LCD_CS_L gpio_direction_output(LCD_CS,0);</span>
<span class="comment">#define LCD_CLK_H gpio_direction_output(LCD_CLK,1);</span>
<span class="comment">#define LCD_CLK_L gpio_direction_output(LCD_CLK,0);</span>

static int major,minor;
struct cdev *lcd;
static dev_t devno;
static struct class *lcd_class;
static int lcd_open(struct inode *inode,struct file *filp);
static int lcd_release(struct inode *inode,struct file *filp);
static int lcd_ioctl(struct inode *inode,struct file *flip,unsigned int <span class="built_in">command</span>,unsigned long arg);
static int lcd_init(void);
static void lcd_exit(void);

struct file_operations lcd_fops ={
    .owner = THIS_MODULE,
    .open =lcd_open,
    .release = lcd_release,
<span class="comment">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,36)</span>
    .unlocked_ioctl = lcd_ioctl,
<span class="comment">#else</span>
    .ioctl = lcd_ioctl
<span class="comment">#endif</span>
};

static void lcd_sendbyte(unsigned char byte)
{
    unsigned int i=0;
    <span class="keyword">for</span>(i=0;i&lt;8;i++)
    {
        LCD_CLK_L;
        udelay(1);
        <span class="keyword">if</span>(byte &amp; 0x80)
        {LCD_SID_H;}
        <span class="keyword">else</span>
        {LCD_SID_L;}
        LCD_CLK_H;
        udelay(1);
        LCD_CLK_L;
        udelay(1);
        byte = byte &lt;&lt; 1;
    }
}

static void lcd12864_write_cmd(unsigned char cmd)
{
    LCD_CS_H;
    lcd_sendbyte(0xf8);
    lcd_sendbyte(0xf0 &amp; cmd);
    lcd_sendbyte(0xf0 &amp; (cmd &lt;&lt; 4));
    LCD_CS_L;
    mdelay(10);
}

static void lcd12864_write_dat(unsigned char dat)
{

    LCD_CS_H;
    lcd_sendbyte(0xfa);
    lcd_sendbyte(0xf0 &amp; dat);
    lcd_sendbyte(0xf0 &amp; (dat &lt;&lt; 4));
    LCD_CS_L;
    mdelay(10);
}
static void lcd12864_init(void)
{
    lcd12864_write_cmd(0x30);
    lcd12864_write_cmd(0x02);
    lcd12864_write_cmd(0x06);
    lcd12864_write_cmd(0x0c);
    lcd12864_write_cmd(0x01);
    lcd12864_write_cmd(0x80);

}
static void lcd12864_clean(void)
{
    lcd12864_write_cmd(0x01);
}
static void lcd_string(unsigned char x,unsigned char y,unsigned char *String)
{
    <span class="keyword">if</span>((x &lt; 8)&amp;&amp;(y &lt; 4))
    {
        switch(y)
        {
            <span class="keyword">case</span> 0:
                lcd12864_write_cmd(0x80|0x00|x);
                <span class="built_in">break</span>;
            <span class="keyword">case</span> 1:
                lcd12864_write_cmd(0x80|0x10|x);
                <span class="built_in">break</span>;
            <span class="keyword">case</span> 2:
                lcd12864_write_cmd(0x80|0x08|x);
                <span class="built_in">break</span>;
            <span class="keyword">case</span> 3:
                lcd12864_write_cmd(0x80|0x18|x);
                <span class="built_in">break</span>;
        }
        <span class="keyword">while</span>(*String !=<span class="string">'\0'</span>)
        {
            lcd12864_write_dat(*String);
            mdelay(50);
            String++;
        }
    }

}    
static int lcd_open(struct inode *inode,struct file *file)
{
    try_module_get(THIS_MODULE);
    lcd12864_init();//init lcd12864 cmd 
    //init lcd12864 background
    lcd_string(0,0,<span class="string">"Linux Chardev"</span>);
    lcd_string(0,1,<span class="string">"LCD12864 Device"</span>);
    lcd_string(0,2,<span class="string">"Initialization"</span>);
    lcd_string(0,3,<span class="string">"Author:Jason"</span>);
    <span class="built_in">return</span> 0;
}
static int lcd_release(struct inode *inode,struct file *file)
{
    module_put(THIS_MODULE);
    lcd12864_clean();//close lcd12864 background
    lcd_string(0,0,<span class="string">"LCD12864 Device"</span>);
    lcd_string(0,1,<span class="string">"Already"</span>);
    lcd_string(0,2,<span class="string">"Closed"</span>);
    <span class="built_in">return</span> 0;
}


<span class="comment">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,36)</span>
int lcd_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
<span class="comment">#else</span>
static int lcd_ioctl(struct inode *inode,struct file *file,unsigned int cmd,unsigned long arg)
<span class="comment">#endif</span>
{
    <span class="keyword">if</span>(_IOC_TYPE(cmd) != LCD_IOC_MAGIC)
    {
        <span class="built_in">return</span> -ENOTTY;
    }
    <span class="keyword">if</span>(_IOC_NR(cmd) &gt; LCD_IOCTL_MAXNR)
    {
        <span class="built_in">return</span> -ENOTTY;
    }

    switch(cmd)
    {
        <span class="keyword">case</span> LCD_LINE:  //待开发
                <span class="built_in">break</span>;
        <span class="keyword">case</span> LCD_ROW:   //待开发
                <span class="built_in">break</span>;
        <span class="keyword">case</span> LCD_CMD:   //待开发
                <span class="built_in">break</span>;
        <span class="keyword">case</span> LCD_DATA:  //待开发
                <span class="built_in">break</span>;
    }
    <span class="built_in">return</span> 0;


}
static int __init lcd_init(void)
{
    int ret=0;

    gpio_free(LCD_SID);
    gpio_free(LCD_CS);
    gpio_free(LCD_CLK);
    ret += gpio_request(LCD_SID,<span class="string">"SID"</span>);
    ret += gpio_request(LCD_CS,<span class="string">"CS"</span>);
    ret += gpio_request(LCD_CLK,<span class="string">"CLK"</span>);
    <span class="keyword">if</span>(ret)
    {
        printk(<span class="string">"request gpio failed "</span>);
        <span class="built_in">return</span> -1;
    }
    ret = 0;
    ret = alloc_chrdev_region(&amp;devno,minor,1,<span class="string">"LCD12864"</span>);
    major = MAJOR(devno);
    <span class="keyword">if</span>(ret &lt; 0)
    {
        printk(KERN_ERR<span class="string">"cannot get major %d\n"</span>,major);
        <span class="built_in">return</span> -1;
    }
    lcd = cdev_alloc();
    <span class="keyword">if</span>(lcd !=NULL)
    {
        cdev_init(lcd,&amp;lcd_fops);
        lcd-&gt;owner = THIS_MODULE;
        <span class="keyword">if</span>(cdev_add(lcd,devno,1) != 0)
        {
            printk(KERN_ERR<span class="string">"add cdev error! \n"</span>);
            goto error;
        }
    }    
    <span class="keyword">else</span>
    {
        printk(KERN_ERR<span class="string">"cdev_alloc error! \n"</span>);
        <span class="built_in">return</span> -1;
    }

    lcd_class = class_create(THIS_MODULE,<span class="string">"lcd_class"</span>);
    <span class="keyword">if</span>(IS_ERR(lcd_class))
    {
        printk(KERN_INFO<span class="string">"create class error!\n"</span>);
        <span class="built_in">return</span> -1;
    }
    device_create(lcd_class,NULL,devno,NULL,<span class="string">"lcd12864"</span>);
    <span class="built_in">return</span> 0;
error:
    unregister_chrdev_region(devno,1);
    <span class="built_in">return</span> ret;

}
static void __exit lcd_exit(void)
{
    cdev_del(lcd);
    unregister_chrdev_region(devno,1);
    device_destroy(lcd_class,devno);
    class_destroy(lcd_class);
}

module_init(lcd_init);
module_exit(lcd_exit);

MODULE_LICENSE(<span class="string">"GPL"</span>);
MODULE_AUTHOR(<span class="string">"ideask,ideask@ideask.cf"</span>);
</code></pre>
<h2 id="2、Makefile"><a href="#2、Makefile" class="headerlink" title="2、Makefile"></a>2、Makefile</h2><pre><code class="bash">CC = arm-fsl-linux-gnueabi-gcc

ifneq ($(KERNELRELEASE),)
obj-m := lcd.o

PWD :=$(shell <span class="built_in">pwd</span>)
KVER :=$(shell uname -r)
KDIR :=/root/linux-2.6.35.3

all:
    $(MAKE) -C $(KDIR) M=$(PWD) modules
clean:
    rm -rf .*.cmd *.o *.mod.c *.ko .tmp_versions
endif
</code></pre>
<h2 id="3、测试程序"><a href="#3、测试程序" class="headerlink" title="3、测试程序"></a>3、测试程序</h2><pre><code class="bash"><span class="comment">#include &lt;stdio.h&gt;</span>
<span class="comment">#include &lt;stdlib.h&gt;</span>
<span class="comment">#include &lt;unistd.h&gt;</span>
<span class="comment">#include &lt;sys/ioctl.h&gt;</span>
<span class="comment">#include &lt;errno.h&gt;</span>
<span class="comment">#include &lt;fcntl.h&gt;</span>


<span class="comment">#define DEV_NAME "/dev/lcd12864"</span>

int main(int argc, char *argv[])
{
    int i;
    int fd = 0;
    fd = open(DEV_NAME,O_RDONLY);
    <span class="keyword">if</span>(fd &lt; 0)
    {
        perror(<span class="string">"Open "</span>DEV_NAME<span class="string">"Failed!\n"</span>);
        <span class="built_in">return</span> -1;
    }
    //close(fd);
    <span class="keyword">while</span>(1);
    <span class="built_in">return</span> 0;
}
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ioctl方式操作LED udev驱动模板]]></title>
      <url>http://ideask.cf/2017/01/22/ioctl-led-udev-char-device/</url>
      <content type="html"><![CDATA[<h2 id="1、驱动源码"><a href="#1、驱动源码" class="headerlink" title="1、驱动源码"></a>1、驱动源码</h2><pre><code class="bash"><span class="comment">#include &lt;linux/init.h&gt;</span>
<span class="comment">#include &lt;linux/module.h&gt;</span>
<span class="comment">#include &lt;linux/fs.h&gt;</span>
<span class="comment">#include &lt;linux/cdev.h&gt;</span>
<span class="comment">#include &lt;linux/device.h&gt;</span>
<span class="comment">#include &lt;linux/version.h&gt;</span>

<span class="comment">#include &lt;asm/mach/arch.h&gt;</span>
<span class="comment">#include &lt;asm/gpio.h&gt;</span>

<span class="comment">#define LED_IOC_MAGIC 'L'    //操作LED的幻数</span>
<span class="comment">#define LED_ON _IO(LED_IOC_MAGIC,0)    //无参数命令</span>
<span class="comment">#define LED_OFF _IO(LED_IOC_MAGIC,1) </span>
<span class="comment">#define LED_IOCTL_MAXNR 2    //</span>

static int major,minor;
struct cdev *led;
static dev_t devno;
static struct class *led_class;

<span class="comment">#define DEVICE_NAME "led" </span>
<span class="comment">#define GPIO_LED_PIN_NUM 116</span>

static int led_open(struct inode *inode,struct file *file)
{
    try_module_get(THIS_MODULE);
    gpio_direction_output(GPIO_LED_PIN_NUM,1);
    <span class="built_in">return</span> 0;
}

static int led_release(struct inode *inode,struct file *file)
{
    module_put(THIS_MODULE);
    gpio_direction_output(GPIO_LED_PIN_NUM,1);
    <span class="built_in">return</span> 0;
}
<span class="comment">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,36)</span>
int led_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
<span class="comment">#else</span>
static int led_ioctl(struct inode *inode,struct file *file,unsigned int cmd,unsigned long arg)
<span class="comment">#endif</span>
{
    <span class="keyword">if</span>(_IOC_TYPE(cmd) != LED_IOC_MAGIC)
    {
        <span class="built_in">return</span> -ENOTTY;
    }
    <span class="keyword">if</span>(_IOC_NR(cmd) &gt; LED_IOCTL_MAXNR)
    {
        <span class="built_in">return</span> -ENOTTY;
    }
    switch(cmd)
    {
        <span class="keyword">case</span> LED_ON:
            gpio_set_value(GPIO_LED_PIN_NUM,0);
            <span class="built_in">break</span>;
        <span class="keyword">case</span> LED_OFF:
            gpio_set_value(GPIO_LED_PIN_NUM,1);
            <span class="built_in">break</span>;
        default:
            gpio_set_value(GPIO_LED_PIN_NUM,0);
            <span class="built_in">break</span>;
    }
    <span class="built_in">return</span> 0;
}

struct file_operations led_fops ={
    .owner = THIS_MODULE,
    .open = led_open,
    .release = led_release,
<span class="comment">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,36)</span>
    .unlocked_ioctl = led_ioctl
<span class="comment">#else</span>
    .ioctl = led_ioctl
<span class="comment">#endif</span>
};
static int __init led_init(void)
{
    int ret;
    gpio_free(GPIO_LED_PIN_NUM);
    <span class="keyword">if</span>(gpio_request(GPIO_LED_PIN_NUM,<span class="string">"led_run"</span>))
    {
        printk(<span class="string">"request %s gpio faile \n"</span>,<span class="string">"led_run"</span>);
        <span class="built_in">return</span> -1;
    }
    ret = alloc_chrdev_region(&amp;devno,minor,1,<span class="string">"led"</span>);
    major = MAJOR(devno);
    <span class="keyword">if</span>(ret &lt; 0)
    {
        printk(KERN_ERR<span class="string">"cannot get major %d \n"</span>,major);
        <span class="built_in">return</span> -1;
    }

    led = cdev_alloc();
    <span class="keyword">if</span>(led != NULL)
    {
        cdev_init(led,&amp;led_fops);
        led-&gt;owner = THIS_MODULE;
        <span class="keyword">if</span>(cdev_add(led,devno,1) != 0)
        {
            printk(KERN_ERR <span class="string">"add cdev error!\n"</span>);
            goto error;
        }
    }
    <span class="keyword">else</span>
    {
        printk(KERN_ERR<span class="string">"cdev_alloc error!\n"</span>);
        <span class="built_in">return</span> -1;
    }

    led_class = class_create(THIS_MODULE,<span class="string">"led_class"</span>);
     <span class="keyword">if</span>(IS_ERR(led_class))
    {
        printk(KERN_INFO<span class="string">"create class error\n"</span>);
        <span class="built_in">return</span> -1;
    }

    device_create(led_class,NULL,devno,NULL,<span class="string">"led"</span>);
    <span class="built_in">return</span> 0;

error:
        unregister_chrdev_region(devno,1);
        <span class="built_in">return</span> ret;
}

static void __exit led_exit(void)
{
    cdev_del(led);
    unregister_chrdev_region(devno,1);
    device_destroy(led_class,devno);
    class_destroy(led_class);
}

module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE(<span class="string">"GPL"</span>);
MODULE_AUTHOR(<span class="string">"ideask,ideask@ideask.cf"</span>);
</code></pre>
<h2 id="2、编译Makefile"><a href="#2、编译Makefile" class="headerlink" title="2、编译Makefile"></a>2、编译Makefile</h2><pre><code class="bash">CC = arm-fsl-linux-gnueabi-gcc

ifneq ($(KERNELRELEASE),)
obj-m := led.o

PWD :=$(shell <span class="built_in">pwd</span>)
KVER :=$(shell uname -r)
KDIR :=/root/linux-2.6.35.3  <span class="comment">#内核文件地址，自定义</span>

all:
    $(MAKE) -C $(KDIR) M=$(PWD) modules
clean:
    rm -rf .*.cmd *.o *.mod.c *.ko .tmp_versions
endif
</code></pre>
<h2 id="3、测试程序"><a href="#3、测试程序" class="headerlink" title="3、测试程序"></a>3、测试程序</h2><pre><code class="bash"><span class="comment">#include &lt;stdio.h&gt;</span>
<span class="comment">#include &lt;stdlib.h&gt;</span>
<span class="comment">#include &lt;unistd.h&gt;</span>
<span class="comment">#include &lt;sys/ioctl.h&gt;</span>
<span class="comment">#include &lt;errno.h&gt;</span>
<span class="comment">#include &lt;fcntl.h&gt;</span>

<span class="comment">#define LED_IOC_MAGIC 'L'    //操作LED的幻数</span>
<span class="comment">#define LED_ON _IO(LED_IOC_MAGIC,0)    //无参数命令</span>
<span class="comment">#define LED_OFF _IO(LED_IOC_MAGIC,1)</span>

<span class="comment">#define DEV_NAME "/dev/led"</span>

int main(int argc, char *argv[])
{
    int i;
    int fd = 0;
    fd = open(DEV_NAME,O_RDONLY);
    <span class="keyword">if</span>(fd &lt; 0)
    {
        perror(<span class="string">"Open "</span>DEV_NAME<span class="string">"Failed!\n"</span>);
        <span class="built_in">return</span> -1;
    }
    <span class="keyword">while</span>(1)
    {
        ioctl(fd,LED_ON);
        //sleep(1);
        ioctl(fd,LED_OFF);
        //sleep(1);
    }
    close(fd);
    <span class="built_in">return</span> 0;
}
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[udev字符设备的程序]]></title>
      <url>http://ideask.cf/2017/01/22/udev-char-device/</url>
      <content type="html"><![CDATA[<h2 id="支持udev的空壳程序"><a href="#支持udev的空壳程序" class="headerlink" title="支持udev的空壳程序"></a>支持udev的空壳程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></div><div class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></div><div class="line"><span class="comment">#include &lt;linux/fs.h&gt;</span></div><div class="line"><span class="comment">#include &lt;linux/cdev.h&gt;</span></div><div class="line"><span class="comment">#include &lt;linux/device.h&gt;</span></div><div class="line"></div><div class="line"> static int major = 232; /* 静态设备号方式的默认值 */</div><div class="line"> static int minor = 0; /* 静态设备号方式的默认值 */</div><div class="line"> module_param(major, int, S_IRUGO);</div><div class="line"> module_param(minor, int, S_IRUGO);</div><div class="line"></div><div class="line"> struct cdev *char_null_udev; /* cdev 数据结构 */</div><div class="line"> static dev_t devno; /* 设备编号 */</div><div class="line"> static struct class *char_null_udev_class;</div><div class="line"></div><div class="line"> <span class="comment">#define DEVICE_NAME "char_null_udev"</span></div><div class="line"></div><div class="line"> static int __init char_null_udev_init(void)</div><div class="line"> &#123;</div><div class="line">	 int ret;</div><div class="line"></div><div class="line">	 <span class="keyword">if</span> (major &gt; 0) </div><div class="line">	 &#123; /* 静态设备号 */</div><div class="line">		devno = MKDEV(major, minor);</div><div class="line">		ret=register_chrdev_region(devno,1,<span class="string">"char_null_udev"</span>);</div><div class="line">	 &#125; </div><div class="line">	 <span class="keyword">else</span> </div><div class="line">	 &#123; /* 动态设备号 */</div><div class="line">		ret=alloc_chrdev_region(&amp;devno,minor,1,<span class="string">"char_null_udev"</span>); /* 从系统获取主设备号 */</div><div class="line">		major = MAJOR(devno);</div><div class="line">	 &#125;</div><div class="line">	 <span class="keyword">if</span> (ret &lt; 0)</div><div class="line">	 &#123;</div><div class="line">		printk(KERN_ERR <span class="string">"cannot get major %d \n"</span>, major);</div><div class="line">		<span class="built_in">return</span> -1;</div><div class="line">	 &#125;</div><div class="line"></div><div class="line">	 char_null_udev = cdev_alloc(); /* 分配 char_null_udev 结构 */</div><div class="line">	 <span class="keyword">if</span> (char_null_udev != NULL) </div><div class="line">	 &#123;</div><div class="line">		 cdev_init(char_null_udev, &amp;major); /* 初始化 char_null_udev 结构 */</div><div class="line">		 char_null_udev-&gt;owner = THIS_MODULE;</div><div class="line">		<span class="keyword">if</span> (cdev_add(char_null_udev, devno, 1) != 0) </div><div class="line">		&#123; /* 增加 char_null_udev 到系统中 */</div><div class="line">			printk(KERN_ERR <span class="string">"add cdev error!\n"</span>);</div><div class="line">			goto error;</div><div class="line">		&#125;</div><div class="line">	 &#125; </div><div class="line">	 <span class="keyword">else</span> &#123;</div><div class="line">		printk(KERN_ERR <span class="string">"cdev_alloc error!\n"</span>);</div><div class="line">		<span class="built_in">return</span> -1;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	//在/sys/class/下创建 char_null_udev_class 目录</div><div class="line">	char_null_udev_class = class_create(THIS_MODULE, <span class="string">"char_null_udev_class"</span>);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(char_null_udev_class)) </div><div class="line">	&#123;</div><div class="line">		printk(KERN_INFO <span class="string">"create class error\n"</span>);</div><div class="line">		<span class="built_in">return</span> -1;</div><div class="line">	&#125;</div><div class="line">	/* 将创建/dev/char_null_udev0 文件 */</div><div class="line">	//device_create(char_null_udev_class, NULL, devno, NULL, <span class="string">"char_null_udev"</span> <span class="string">"%d"</span>,MINOR(devno));</div><div class="line">	/* 将创建/dev/char_null_udev 文件 */</div><div class="line">	device_create(char_null_udev_class, NULL, devno, NULL, <span class="string">"char_null_udev"</span>);</div><div class="line"></div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line"></div><div class="line">	error:</div><div class="line">		unregister_chrdev_region(devno, 1); /* 释放已经获得的设备号 */</div><div class="line">	<span class="built_in">return</span> ret;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> static void __exit char_null_udev_exit(void)</div><div class="line"> &#123;</div><div class="line">	device_destroy(char_null_udev_class, devno);</div><div class="line">	class_destroy(char_null_udev_class);</div><div class="line">	cdev_del(char_null_udev); /* 移除字符设备 */</div><div class="line">	unregister_chrdev_region(devno, 1); /* 释放设备号 */</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> module_init(char_null_udev_init);</div><div class="line"> module_exit(char_null_udev_exit);</div><div class="line"></div><div class="line"> MODULE_LICENSE(<span class="string">"GPL"</span>);</div><div class="line"> MODULE_AUTHOR(<span class="string">"Jason"</span>);</div></pre></td></tr></table></figure>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h2><p> 第(1)~(5)行是所需要的头文件；<br> 第(7)~(8)行用变量设定设备的主次设备号；<br> 第(9)~(10)行是模块参数，驱动支持加载的时候指定主次设备号；<br> 第(12)行定义一个 cdev 全局变量 char_null_udev；<br> 第(13)行的 dev_t devno 用来保存设备编号；<br> 第(14)行是定义 class 结构；<br> 第(16)行定义设备名为 char_null_udev；<br> 第(18)~(71)是模块的初始化代码，行完成设备注册以及设备节点创建：<br> 第(22)~(31)行，根据 major 变量，可以静态或者动态获取设备编号：如果是设<br>备号，需要用 MKDEV 构建成设备编号（行(24)）； 如果是动态获取设备编号，<br>还需在(29)行获取主设备号；<br> 第(38)行通过 cdev_alloc 分配一个 cdev 数据结构 char_null_udev；<br> 如果分配成功，则在(41)~(42)行进行初始化；注意 cdev_init()的第 2 个参数，<br>本应该传入驱动操作方法 fops 的地址，但是没有实现 fops，就传入一个有效<br>地址，防止运行错误；<br> 第(43)行通过 cdev_add 将 char_null_udev 添加到系统中，如果添加失败，则需<br>要释放已经获取的设备号并退出；<br> 第(55)行在 sysfs 的 class 目录下创建 char_null_udev_class 目录；<br> 第(62)或(64)行是在 sysfs 系统中创建设备节点；<br> 第(73)~(79)是模块的退出代码，完成资源释放工作：<br> 第(75)行删除 char_null_uedv 结构；<br> 第(78)行释放设备号；<br> 第(77)行删除 sysfs 中的设备节点；<br> 第(76)行销毁 sysfs 中的 class。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[简单的字符设备驱动指南]]></title>
      <url>http://ideask.cf/2017/01/22/char-device/</url>
      <content type="html"><![CDATA[<h2 id="1、头文件"><a href="#1、头文件" class="headerlink" title="1、头文件"></a>1、头文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;linux/module.h&gt;  </span></div><div class="line"><span class="comment">#include &lt;linux/init.h&gt;是必不可少的。</span></div></pre></td></tr></table></figure>
<h2 id="2、模块初始化函数"><a href="#2、模块初始化函数" class="headerlink" title="2、模块初始化函数"></a>2、模块初始化函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static int __init module_init_func(void)</div><div class="line">&#123;</div><div class="line">初始化代码</div><div class="line">&#125;</div><div class="line">module_init(module_init_func);</div></pre></td></tr></table></figure>
<h2 id="3、模块退出函数"><a href="#3、模块退出函数" class="headerlink" title="3、模块退出函数"></a>3、模块退出函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void __exit module_exit_func(void)</div><div class="line">&#123;</div><div class="line">模块退出代码</div><div class="line">&#125;</div><div class="line">module_exit(module_exit_func);</div></pre></td></tr></table></figure>
<h2 id="4、许可证"><a href="#4、许可证" class="headerlink" title="4、许可证"></a>4、许可证</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</div><div class="line">MODULE_AUTHOR(<span class="string">"Jason_lin &lt;Linux@ideask.cf&gt;"</span>);</div><div class="line">MODULE_DESCRIPTION(<span class="string">"beep Driver"</span>);</div><div class="line">MODULE_VERSION(<span class="string">"V1.00"</span>);</div></pre></td></tr></table></figure>
<h2 id="5、printk语句"><a href="#5、printk语句" class="headerlink" title="5、printk语句"></a>5、printk语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define KERN_EMERG "&lt;0&gt;" /* system is unusable */</span></div><div class="line"><span class="comment">#define KERN_ALERT "&lt;1&gt;" /* action must be taken immediately */</span></div><div class="line"><span class="comment">#define KERN_CRIT "&lt;2&gt;" /* critical conditions */</span></div><div class="line"><span class="comment">#define KERN_ERR "&lt;3&gt;" /* error conditions */</span></div><div class="line"><span class="comment">#define KERN_WARNING "&lt;4&gt;" /* warning conditions */</span></div><div class="line"><span class="comment">#define KERN_NOTICE "&lt;5&gt;" /* normal but significant condition */</span></div><div class="line"><span class="comment">#define KERN_INFO "&lt;6&gt;" /* informational */</span></div><div class="line"><span class="comment">#define KERN_DEBUG "&lt;7&gt;" /* debug-level messages */</span></div></pre></td></tr></table></figure>
<h2 id="6、Simple-demon"><a href="#6、Simple-demon" class="headerlink" title="6、Simple demon"></a>6、Simple demon</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;linux/module.h&gt;</span></div><div class="line"><span class="comment">#include &lt;linux/init.h&gt;</span></div><div class="line"></div><div class="line"> static int num = 3;</div><div class="line"> static char *whom = <span class="string">"master"</span>;</div><div class="line"></div><div class="line"> module_param(num, int, S_IRUGO);</div><div class="line"> module_param(whom, charp, S_IRUGO);</div><div class="line"></div><div class="line"> static int __init hello_init(void)</div><div class="line"> &#123;</div><div class="line">  printk(KERN_INFO <span class="string">"%s, I get %d\n"</span>, whom, num);</div><div class="line">  <span class="built_in">return</span> 0;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> static void __exit hello_exit(void)</div><div class="line"> &#123;</div><div class="line">  printk(<span class="string">"I'll be leaving, bye!\n"</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> module_init(hello_init);</div><div class="line"> module_exit(hello_exit);</div><div class="line"></div><div class="line"> MODULE_LICENSE(<span class="string">"GPL"</span>);</div></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre><code class="bash"><span class="comment"># insmod hellop.ko whom="MASTER" num=5</span>
</code></pre>
<p>MASTER, I get 5</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IDEASK team building]]></title>
      <url>http://ideask.cf/2017/01/21/IDEASK-team-building/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://ideask.cf/2017/01/21/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
